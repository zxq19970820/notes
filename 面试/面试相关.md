# 一.post与get提交方式区别



**最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。**



1. GET 请求的数据会==附在 URL 之后==（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数之间以&相连，如：login.action?name=zhagnsan&password=123456。POST 把提交的数据则放置在是 ==HTTP 包的包体中==。

2. GET 方式提交的数据最多只能是 1024 字节，理论上 POST 没有限制，可传较大量的数据。其实这样说是错误
的，不准确的：
“GET 方式提交的数据最多只能是 1024 字节"，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083 字节(2K+35)。对于其他浏览器，如Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。

3. POST 的安全性要比 GET 的安全性高。注意：这里所说的安全性和上面 GET 提到的“安全”不是同个概念。上
    面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的 Security 的含义，比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻击。
    Get 是向服务器发==索取数据==的一种请求，而 Post 是向服务器==提交数据==的一种请求，在 FORM（表单）中，Method默认为"GET"，实质上，GET 和 POST 只是发送机制不同，并不是一个取一个发！

  

doGet 和 doPost 都是接受用户请求的方法，doGet 处理 get 请求，doPost 处理
post 请求，doGet 用于地址栏提交，doPost 用于表单提交，在页面提交数据时，get 的
数据大小有限制 4k，post 没有限制，get 请求提交的数据会在地址栏显示，post 不显示，
所以 post 比 get 安全



# 二.原生 jdbc 操作数据库流程



第一步：Class.forName()加载数据库连接驱动；

第二步：DriverManager.getConnection()获取数据连接对象;

第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;

第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();

第五步：关闭结果集、关闭会话、关闭连接。



~~~java
/*
 * PreparedStatement接口实现数据表的查询操作
 */
public class JDBCDemo05 {
 
	public static void main(String[] args) throws Exception {
		// 1.注册驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取连接对象
		String url = "jdbc:mysql://localhost:3306/itheima";
		Connection conn = DriverManager.getConnection(url, "root", "root");
 
		// 3.拼写修改的SQL语句,参数采用?占位
		String sql = "select * from sort";
		// 4.调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象
		PreparedStatement pst = conn.prepareStatement(sql);
		// 5.调用pst方法执行SQL语句
		ResultSet rs = pst.executeQuery();
		while(rs.next()){
			System.out.println(rs.getString("sid")+"\t"+rs.getString("sname")+"\t"+rs.getString("sprice")+"\t"+rs.getString("sdesc"));
		}
		// 7.关闭资源
		rs.close();
		pst.close();
		conn.close();
	}

~~~





### 使用preparestatement防止SQL注入的方式,更新数据库信息



~~~java
1. 注册驱动
 Class.forName("com.mysql.jdbc.Driver");
2.获取数据库连接
Connection conn  =DriverManager.getConnection(url,user,p);

3.创建向数据发送sql 的statement对象
Statement stmt = conn.CreateStatement();

4. 向数据库发送sql
ResultSet rs  = stmt.executeQuery(sql)//select语句
int updateaSum = stmt.executeUpdate(sql)//insert,update delete语句

5. 处理结果集
while(rs.next()){
	rs.getString(列名)
	rs.getInt(列名)
}
6. 关闭资源
rs.close();
stmt.close();
conn.close();
~~~



~~~java

public class JDBCDemo04 {
 
	public static void main(String[] args) throws Exception {
		// 1.注册驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取连接对象
		String url = "jdbc:mysql://localhost:3306/itheima";
		Connection conn = DriverManager.getConnection(url, "root", "root");
 
		// 3.拼写修改的SQL语句,参数采用?占位
		String sql = "UPDATE sort SET sname=?,sprice=? WHERE sid=?";
        
		// 4.调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象
		PreparedStatement pst = conn.prepareStatement(sql);
		// 5.调用pst的方法setXXX设置?占位
		pst.setObject(1, "汽车美容");
		pst.setObject(2, 49988);
		pst.setObject(3, 7);
		// 6.调用pst方法执行SQL语句
		pst.executeUpdate();
		// 7.关闭资源
		pst.close();
		conn.close();
	}
}
~~~



# 三.什么要使用 PreparedStatement



1、 PreparedStatement 接口继承 Statement， PreparedStatement 实例包含已编译的 SQL 语句，所以其执行
速度要快于 Statement 对象。
2 、 作 为 Statement 的 子 类 ， PreparedStatement 继 承 了 Statement 的 所 有 功 能 。 三 种 方
法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数
3、在 JDBC 应用中,在任何时候都不要使用 Statement，原因如下：
一、代码的可读性和可维护性.Statement 需要不断地拼接，而 PreparedStatement 不会。
二、PreparedStatement 尽最大可能提高性能.DB 有缓存机制，相同的预编译语句再次被调用不会再次需要
编译。
三、最重要的一点是极大地提高了安全性.Statement 容易被 SQL 注入，而 PreparedStatementc 传入的内容不会和 sql 语句发生任何匹配关系。



# 四.转发和重定向区别

转发	
      服务器行为
     转发——>客户浏览器发送HTTP请求——>web服务器接受请求——>调用内部一个方法在容器内部完成请求处理和转发动作——>再将转发跳转到的那个网页资源返回给客户；  转发只能在同一个容器内完成 转发的时候浏览器地址是不会变的，在客户浏览器里只会显示第一次进入的那个网址或者路径，客户看不到这个过程，只是得到了想要的目标资源。转发行为浏览器只做了一次请求。（转发只能跳转一次）

    public void doGet(HttpServletRequest request, HttpServletResponse response)throws 	ServletException, IOException{
    	System.out.println("=====");
    	request.getRequestDispatcher("/welcome").forward(request, response);
    
    }
     
    public void doPost(HttpServletRequest request, HttpServletResponse response)throws 	ServletException, IOException{
    	doGet(request, response);
     
    }



```
//    转发
    @RequestMapping("/testForward")
    public String testForward() {
        System.out.println("AccountController 的 testForward 方法执行了。。。。");
        return "forward:/view/hello.jsp";
    }
//    需要注意的是，如果用了 formward：则路径必须写成实际视图 url，不能写逻辑视图。
//    它相当于“request.getRequestDispatcher("url").forward(request,response)”。使用请求
//    转发，既可以转发到 jsp，也可以转发到其他的控制器方法。
```





重定向
      客户端行为
      重定向——>客户浏览器发送HTTP请求——>web服务器接受请求后发送302状态码以及新的位置给客户浏览器——>客户浏览器发现是302响应，则自动再发送一个新的HTTP请求，请求指向新的地址（302：Found  临时移动，但资源只是临时被移动。即你访问网址A，但是网址A因为服务器端的拦截器或者其他后端代码处理的原因，会被重定向到网址B。）——>服务器根据此请求寻找资源发个客户；再客户浏览器中显示的是重定向之后的路径，客户可以看到地址的变化。重定向行为浏览器做了至少两次请求。（重定向可以跳转多次）

      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws 	ServletException, IOException {
    
    	response.sendRedirect("welcome");
    }



```
 /**
     * 重定向
     * @return
     */
    @RequestMapping("/testRedirect")
    public String testRedirect() {
        System.out.println("AccountController 的 testRedirect 方法执行了。。。。");
        return "redirect:testReturnModelAndView";
    }
    //    contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect:
//    它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不
//    能写在 WEB-INF 目录中，否则无法找到。
```





# 五.jsp四大域和九大内置对象

## 1）



==四大域对象==
（1）page    page 域-指当前页面，在当前 jsp 页面有效，跳到其它页面失效
（2）request        request 域-指一次请求范围内有效，从 http 请求到服务器处理结束，返回响应的整个过程。
在这个过程中使用 forward（请求转发）方式跳转多个 jsp，在这些页面里你都可以使用这个变量
（3）session 			session 域-指当前会话有效范围，浏览器从打开到关闭过程中，转发、重定向均可以使用
（4）application	 域-指只能在同一个 web 中使用，服务器未关闭或者重启，数据就有效



==九大内置对象==

![image-20200909211416919](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200909211416919.png)

![image-20200909211439336](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200909211439336.png)



## 2）

| **隐式对象** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| request      | 转译后对应HttpServletRequest/ServletRequest对象              |
| response     | 转译后对应HttpServletRespons/ServletResponse对象             |
| session      | 转译后对应HttpSession对象                                    |
| application  | 转译后对应ServletContext对象                                 |
| out          | 转译后对应JspWriter对象，其内部关联一个PringWriter对象       |
| page         | 转译后对应this                                               |
| config       | 转译后对应ServletConfig对象                                  |
| exception    | 转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面) |
| pageContext  | 转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性 |

Jsp隐含变量

1、out 来源于[Java](http://lib.csdn.net/base/17).io.Writer类，它用于发送输出流到客户端。
2、request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。
3、response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。
4、pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。
5、session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。
6、application 来源于javax.servlet.ServletContext。
7、config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。
8、page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。
9、exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。

JSP九种内置对象：

#### 一 request对象：

该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面

#### 二 response对象：

对客户的请求做出动态的响应，向客户端发送数据。 

#### 三 session对象

1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。 
从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。
2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。

#### 四 aplication对象

1．什么是application: 
服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。
2．application对象常用方法: 
(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。
(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。 

#### 五 out对象

  out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。

#### 六 page [java.lang](http://zhidao.baidu.com/search?word=java.lang&fr=qb_search_exp&ie=utf8).Object

对应this关键字。JSP网页本身 
page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系： 
Object page = this; 
在JSP页面中，很少使用page对象。

#### 七 config

javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。

#### 八 exception    [java.lang](http://zhidao.baidu.com/search?word=java.lang&fr=qb_search_exp&ie=utf8).Throwable 的实例

该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。

 

#### 九 pageContext

javax.servlet.jsp.PageContext 的实例，对象直译时可以称作“页面上下文”对象，代表的是当前页面运行的一些属性，通过此对象可以拿到其他8大对象，使用该对象可以访问页面中的共享数据。常用的方法有getServletContextO和getServletConfigO等。

//使用pageContext 设置属性，该属性默认在page 范围内 
pageContext. setAttribute ("page" , "hello") ; 

 //使用request 设置属性，该属性默认在request 范围内 
request. setAttribute ("request" , "hello"); 

 //使用pageContext将属性设置在request 范围中 
pageContext.setAttribute("request2" , "hello" , pageContext.REQUEST_SCOPE); 

 // 使用session将属性设置在session 范围中 
session.setAttribute("session" , "hello"l; 

 //使用pageContext将属性设置在session范围中 
pageContext.setAttribute("session2" , "hello" , pageContext.SESSION_SCOPE); 

 //使用application将属性设置在application范围中 
application. setAttribute ("app" , "hello") ; 

 //使用pageContext 将属性设置在application 范围中 
pageContext.setAttribute("app2" , "hello" , pageContext.APPL 工CATION_SCOPE) ;

 



## 四大作用域

**==四个作用域==：request域 session域 application域 page域**

 

 

application：
全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。

 

session：
会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。

 

request：
请求作用域，就是客户端的一次请求。

 

[page](http://blog.darkmi.com/tag/page)：
一个JSP页面。

 

以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。

 

 

 

 

从显示的结果来看，我们可以直观的得出结论：

　　page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。

　　request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。

　　session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。application里的变量一直在累加，除非你重启tomcat，否则它会一直变大。

而作用域规定的是变量的有效期限。

　　如果把变量放到page里，就说明它的作用域是page，它的有效范围只在当前jsp页面里。

　　从把变量放到pageContext开始，到jsp页面结束，你都可以使用这个变量。

　　如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。

　　所谓请求周期，就是指从http请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个jsp页面，在这些页面里你都可以使用这个变量。

　　如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。

　　所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。

　　如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。

　　整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。

　　application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。

　　与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request,session都是完全隔离的，无论如何修改都不会影响其他人的数据。

　　我们使用public Object getAttribute(String name)获得变量值，使用public void setAttribute(String name, Object value)将变量值保存到对应作用域中。举个pageContext的例子就是：

　　// page

　　Integer countPage = (Integer) pageContext.getAttribute("countPage");

　　if (countPage == null) {

　　pageContext.setAttribute("countPage", 1);

　　} else {

　　pageContext.setAttribute("countPage", countPage + 1);

　　}

　　这里先从pageContext中取出名为countPage的整数，因为返回的都是[Java](http://lib.csdn.net/base/17).lang.Object类型，所以需要强制转换成我们需要的整形。这里取得的变量如果不存在就会返回null，通过判断countPage == null来辨别变量是否存在，如果不存在就设置为1，如果存在就进行累加，最后使用setAttribute()方法将修改后的变量值放入pageContext。将其中的pageContext换成request, session, application就可以操作其他三个作用域中的变量。

 

request           请求对象　        类型 javax.servlet.ServletRequest      作用域 Request

response            响应对象         类型 javax.servlet.SrvletResponse      作用域 Page

pageContext       页面上下文对象      类型 javax.servlet.jsp.PageContext     作用域 Page

session        会话对象         类型 javax.servlet.http.HttpSession     作用域 Session

application     应用程序对象       类型 javax.servlet.ServletContext       作用域 Application

out           输出对象         类型 javax.servlet.jsp.JspWriter        作用域 Page

config        配置对象         类型 javax.servlet.ServletConfig        作用域 Page

page          页面对象         类型 javax.lang.Object               作用域 Page

exception     例外对象         类型 javax.lang.Throwable            作用域 page





# 六.什么是 jsp，什么是 Servlet？jsp 和 Servlet 有什么区别



==jsp== 本质上就是一个 Servlet，它是 Servlet 的一种特殊形式（由 SUN 公司推出），每个 jsp 页面都是一个 servlet
实例。

==Servlet== 是由 Java 提供用于开发 web 服务器应用程序的一个组件，运行在服务端，由 servlet 容器管理，用来生
成动态内容。一个 servlet 实例是**实现了特殊接口 Servlet 的 Java 类**，所有自定义的 servlet 均必须实现 Servlet 接口。

==区别：==
jsp 是 html 页面中内嵌的 Java 代码，侧重页面显示；
Servlet 是 html 代码和 Java 代码分离，侧重逻辑控制，mvc 设计思想中 jsp 位于视图层，servlet 位于控制层
Jsp 运行机制：如下图

![image-20200909212718460](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200909212718460.png)



JVM 只能识别 Java 类，并不能识别 jsp 代码！web 容器收到以.jsp 为扩展名的 url 请求时，会将访问请求交给
tomcat 中 jsp 引擎处理，每个 jsp 页面第一次被访问时，jsp 引擎将 jsp 代码解释为一个 servlet 源程序，接着编译servlet 源程序生成.class 文件，再有 web 容器 servlet 引擎去装载执行 servlet 程序，实现页面交互。





# 七.@RequstMapping的处理类

HandeleMapping与HandlerAdapter



**==HandlerMapping==**这个组件，它负责的是定位请求处理器Handler。这是SpringMvc处理流程的第二步。那么，当定位到Handler之后，DispatcherServlet会将得到的Handler告知HandlerAdapter

**==HandlerAdapter==**再根据请求去定位请求的具体处理方法是哪一个。**



![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/1370903-20180827201021158-682489195.png)



- ### 一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理

- ### DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）

- ### HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链 

- ### DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet

- ### DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View

- ### DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）

- ### DispatcherServlet 将页面响应给用户

 

------

 

## **组件说明：**

- ###  DispatcherServlet：前端控制器

​      **用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，**

​      **由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。**

 

- ### HandlerMapping：处理器映射器

　　　**HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，**

　　  **例如：配置文件方式，实现接口方式，注解方式等。**

 

- ###  Handler：处理器

　　 **Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。**

​    **由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。**

 

- ### HandlAdapter：处理器适配器

　　**通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。**

 

- ### ViewResolver：视图解析器

　　**View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，**

　　**再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。**

 

- ### View：视图

　　**springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。**

　　**一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。**

# 八.servlet与bean生命周期



Servlet 的执行流程也就是 servlet 的生命周期，当服务器启动的时候生命周期开始，然后通过 init()《启动顺序根据 web.xml 里的 startup-on-load 来确定加载顺
序》方法初始化 servlet，再根据不同请求调用 doGet 或 doPost 方法，最后再通过 destroy()
方法进行销毁。

![image-20200929215846240](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200929215846240.png)



Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：

- ==加载==容器通过类加载器使用servlet类对应的文件加载servlet
- ==创建==    通过调用servlet构造函数创建一个servlet对象
- ==初始化==Servlet 通过调用 **init ()** 方法进行初始化。
- ==处理客户请求==Servlet 调用 **service()** 方法来处理客户端的请求。
- ==卸载==Servlet 通过调用 **destroy()** 方法终止（结束）。
- 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的



**==bean生命周期==**

==单例对象==：scope="singleton"
一个应用只有一个对象的实例。它的作用范围就是整个引用。
生命周期：
对象出生：当应用加载，**创建容器**时，对象就被创建了。
对象活着：只要容器在，对象一直活着。
对象死亡：当应用卸载，销毁容器时，对象就被销毁了。



==多例对象==：scope="prototype"
每次访问对象时，都会重新创建对象实例。
生命周期：
对象出生：当**使用对象**时，创建新的对象实例。
对象活着：只要对象在使用中，就一直活着。
对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。





# 九.静态包含与动态包含



**动态包含\<jsp :include page="a.jsp"/>与**

**静态包含<%@include file=“fileurl”%>的区别**



**1.**动态包含用的元素是page，而且有两种形式。静态包含用的是file,只有一种形式。

**2.**生成的文件不同，静态的包含是将两个jsp文件二合一，生成一个以包含页面命名的servlet和class文件，动态包含的两个jsp文件各自生成自己的servlet和class文件。

**3.** 传参方式一：<jsp:include page=“a.jsp?param=123”/>时被包含的jsp页面是可以访问该参数的。

**4.** 传参方式二：

​      <jsp:include page=“a.jsp”>

​           <jsp:param name=“” value=“”>

​          <jsp:param name=“” value=“”>

​      </ jsp:include >

**5.**在客户端访问包含页面时地址栏后面直接加上参数后传递，这种形式的传参是客户端送来的，但是这两个页面的request对象不是同一个，因为**3中**已经说了包含的页面可以向被包含的页面传递参数，所以被包含的request对象含的参数个数应该大于等于包含页面的参数个数的。所以它们各有各的request对象。而且被包含的jsp页面可以访问传到包含页面的参数。

**6.**动态包含只有在执行到它的时候才加载，所以它才叫动态包含。





# 十.final与finalize

1、final修饰符（关键字）。被final修饰的类，就意味着不能再派生出新的子类，==不能==作为父类而被子类==继承==。因此一个类不能既被abstract声明，又被final声明。将==变量==或方法声明为final，可以保证他们在使用的过程中==不被修改==。被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。被final声明的==方法==也同样只能使用，即==不能方法重写==。

```java
public  class  finalTest{

    final   int  a=6;//final成员变量不能被更改
    final   int  b;//在声明final成员变量时没有赋值，称为空白final

    public finalTest(){
        b=8;//在构造方法中为空白final赋值
    }

    int do(final x){//设置final参数，不可以修改参数x的值
        return x+1;
    }

    void  doit(){
        final int i = 7;//局部变量定义为final，不可改变i的值
    }
}
```

2、finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。

3、finalize是方法名。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前 做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。finalize（）方法是在垃圾收集器==删除对象之前==对这个对象==调用==的。 





```
final:修饰为常量，一旦作为方法的形参或局部变量、全局变量使用，一旦赋值，就不能在被修改
finally:通常和try...catch...finally搭配使用，中无论是否发生异常，都会执行finally里的方法
finalized:方法名，在执行垃圾处理时，会进行调用此方法进行前期的处理工作；
```





# 十一.Collection与Collections,Arrays工具类



Collection<E>是Java集合框架中的**基本接口**；





Collections是Java集合框架提供的一个**工具类**，其中**包含了大量用于操作或返回集合的静态方法**。

**排序(Sort)**

**混排（Shuzffling）**

**反转(Reverse)**

max(collection c)

min(collection c)



**Arrays**，操作数组的工具类

Array.sort(arr)







# 十二.对this，static的理解



## **this**

### 	1.调用成员变量，

​						*解决与局部变量名称冲突问题**

​		

```java
class person{
	int a=10;
	pubsic void hello(){
		int a=20;
		system.out.printf(a)
	}
}
```

​			

### 		2.调用成员方法

​		

~~~java
class person{
	
	pubsic void hello(){
		system.out.printf("1")
	}
    
    pubsic void hi(){
        this.hello();
		system.out.printf("2")
	}
}
~~~





### 		3.构造方法之间互相调用



- ==只能==在==构造方法中==this调用其他构造方法，不能在成员方法中使用
- 在构造方法中，使用this调用的构造方法必须==位于第一行==，且==只能出现一次==
- 不能在一个类的两个构造方法中使用this==互相调用==



~~~java
class person{
    publi person(){
     	system.out.printf("无参构造方法被调用")
    }
    publi person(String name){
        this();
     	system.out.printf("有参构造方法被调用")
    }
    
}
~~~



## static



### 1.静态变量



是被 static 修饰符修饰的变量，也称为==类变量==，它属于类，不属于类的任何一个对象，

一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；

**在内存中只有一份，被一个类的所有实例共享**

**static只能修饰成员变量，不能修饰局部变量**

~~~java
class student{
	static String schhoolName;

}

~~~

实例: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对
象共享内存。



### 2.静态方法



可以用  类名.方法进行调用



==静态方法中只能访问用static修饰的成员==

原因：**没有被static修饰的成员需要创建对象才能访问，而静态方法在被调用时就可以不创建任何对象**

声明为 static 的方法==不能被重写==，==但是能够被再次声明==。

~~~java
class student{
	public static void hello(){
          system.out.printf("静态方法执行了")
    }

}

~~~











### 3.静态代码块



随着类的加载而加载，且只加载一次，用来对类的成员变量进行初始化

~~~java
class student{
    int a;
	static {
        a=10;
        system.out.printf("静态代码块执行了")
    }

}
~~~





# 十三.单例模式



**[菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)**

## 饿汉式

线程安全，比较常用，但容易产生垃圾，因为一开始就初始化

~~~java
public class SingletonDemo {
    private static SingletonDemo instance=new SingletonDemo();
    private SingletonDemo(){

    }
    public static SingletonDemo getInstance(){
        return instance;
    }
}
~~~







## 懒汉式

非线程安全,延迟初始化，严格意义上不是单例模式

~~~java
public class SingletonDemo {
    private static SingletonDemo instance;
    private SingletonDemo(){

    }
    public static SingletonDemo getInstance(){
        if(instance==null){
            instance=new SingletonDemo();
        }
        return instance;
    }
}
~~~



## 线程安全的懒汉模式

~~~java
public class SingletonDemo {
    private static SingletonDemo instance;
    private SingletonDemo(){

    }
    public static synchronized SingletonDemo getInstance(){
        if(instance==null){
            instance=new SingletonDemo();
        }
        return instance;
    }
}
~~~



## 双检锁单例模式

线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。

![image-20200917211134643](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200917211134643.png)

双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避
免多线程问题。由于 singleton=new Singleton()对象的创建在 JVM 中可能会进行重排序，在多线程
访问下存在风险，使用 volatile 修饰 signleton 实例变量有效，解决该问题。





# 十四.内部类





~~~java
class OuterClass {   // 外部类
    // ...
    class NestedClass { // 嵌套类，或称为内部类
        // ...
    }
}
~~~





### 成员内部类



~~~java
class OuterClass {
  	int x = 10;

  class InnerClass {
  	  int y = 5;
  }
}

public class MyMainClass {
 	 public static void main(String[] args) {
  		  OuterClass myOuter = new OuterClass();
   		  OuterClass.InnerClass myInner = myOuter.new InnerClass();
  		  System.out.println(myInner.y + myOuter.x);
  }
}
~~~

结果：15



### 私有的内部类

~~~java
class OuterClass {
  int x = 10;

  private class InnerClass {
    int y = 5;
  }
}

public class MyMainClass {
  public static void main(String[] args) {
    OuterClass myOuter = new OuterClass();
    OuterClass.InnerClass myInner = myOuter.new InnerClass();
    System.out.println(myInner.y + myOuter.x);
  }
}
~~~

结果    报错

~~~java
MyMainClass.java:12: error: OuterClass.InnerClass has private access in OuterClass
    OuterClass.InnerClass myInner = myOuter.new InnerClass();
~~~





### 静态内部类

~~~java
class OuterClass {
  int x = 10;

  static class InnerClass {
    int y = 5;
  }
}

public class MyMainClass {
  public static void main(String[] args) {
    OuterClass.InnerClass myInner = new OuterClass.InnerClass();
    System.out.println(myInner.y);
  }
}
~~~

结果 5





### 从内部类访问外部类成员

~~~java
class OuterClass {
  int x = 10;

  class InnerClass {
    public int myInnerMethod() {
      return x;
    }
  }
}

public class MyMainClass {
  public static void main(String[] args) {
    OuterClass myOuter = new OuterClass();
    OuterClass.InnerClass myInner = myOuter.new InnerClass();
    System.out.println(myInner.myInnerMethod());
  }
}
~~~



结果 		10



## 二. 

 链接：https://www.jianshu.com/p/a9467e690eb0

### 1.1 成员内部类

此时的内部类相当于是外部类的一个普通成员，只要当外部类被实例化成一个对象后，借用该对象就可以对内部类进行操作。

通常成员内部类表现为如下的代码形式：



```java
public class Outer {    
    private String outerValue = "outer";
    // 成员内部类，相当于外部类的一个成员变量
    public class Inner {
        private String innerValue = "inner";    
        public void printInner(){
            System.out.println("访问外部类的私有属性:" + outerValue);
            System.out.println("访问内部类的私有属性:" + innerValue);
        }
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        // 01使用成员内部类
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
      
        inner.printInner();
    }
}
```

在使用成员内部类的时候，需要记住以下几点：

- 内部类可以直接使用外部类的任何属性和方法，即使是private的。
- 外部类不能直接使用内部类的属性及方法，只能通过内部类的对象来使用。
- 内部类中不能包含static的内容。
- 内部类中需要使用外部类的对象时，使用`outer.this`来指代。

### 1.2 静态内部类

静态内部类又称为嵌套内部类，是在外部类中具有static关键字声明的内部类，相当于是外部类的类变量。

通常静态内部类表现为如下的代码形式：



```java
public class Outer2 {
    private String outerValue1 = "outerValue1";
    private static String outerValue2 = "outerValue2";
    // 静态内部类/嵌套类
    public static class Inner2{
        private String innerValue1 = "innerValue1";
        public void printInfo(){
            System.out.println("访问外部类中的私有属性:" + new Outer2().outerValue1);
            System.out.println("访问外部类中的静态变量:" + Outer2.outerValue2);
            System.out.println("访问内部类中的私有属性:" + innerValue1);
        }
    }
}
```



```java
public class Test {
    public static void main(String[] args) {    
        // 02使用静态内部类/嵌套类
        Outer2.Inner2 inner2 = new Outer2.Inner2();
        inner2.printInfo();
}
```

在使用静态内部类的时候，需要记住以下几点：

- 静态内部类的内部不能直接访问外部类的非静态成员，只能通过实例化外部类的对象，然后通过该对象进行访问。
- 创建静态内部类的对象时，不需要像成员内部类一样需要先行创建外部类的对象，而是直接使用内部类的名称即可创建。

### 1.3 局部内部类

局部内部类是出现在外部类的方法或者某个代码块的作用域范围内的内部类，通常表现为如下的代码形式：



```java
public class Outer3 {
    private String outerValue = "outerValue";
    // 在方法内部定义的局部内部类
    public void outerInfo(){
        final String methodValue = "methodValue";
        class Inner3 {
            String innerValue = "innerValue";
            public void printInner3(){
                System.out.println("访问外部类的属性：" + outerValue);
                System.out.println("访问外部类的方法的常量：" + methodValue);
                System.out.println("访问内部类的属性：" + innerValue);
            }
        }
        Inner3 inner3 = new Inner3();
        inner3.printInner3();
    }
    
    // 在作用域内部定义的局部内部类
    public void outerInfo2(boolean flag){
        if(flag){
            final String methodValue2 = "methodValue2";
            class Inner4{
                String innerValue2 = "innerValue2";
                public void printInner4(){
                    System.out.println("访问外部类的属性：" + outerValue);
                    System.out.println("访问外部类的方法的常量：" + methodValue2);
                    System.out.println("访问内部类的属性：" + innerValue2);
                }
            }
            Inner4 inner4 = new Inner4();
            inner4.printInner4();
        }else{
            System.out.println("outerInfo2：else");
        }
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        // 03使用局部内部类
        Outer3 outer3 = new Outer3();
        outer3.outerInfo();
        outer3.outerInfo2(true);
}
```

在使用局部内部类的时候，需要记住以下几点：

- 局部内部类仅在作用域范围内有效，超出范围则不再可使用。
- 局部内部类中可以使用方法或者代码块级别的变量，但是要求它们必须是final类型的常量。

### 1.4 匿名内部类

匿名内部类没有类名，通常被设计为只使用一次，用以简化代码的书写，通常表现为如下的代码形式：



```java
public class Outer4 {
    private String outerValue = "outerValue";
    // 在方法内部使用匿名内部类
    public Inner5 getInnerInfo(final String name, String value){
        final String methodValue = "methodValue";
        return new Inner5(){
            private String innerValue = name;
            @Override
            public String getInner5() {
                System.out.println("访问外部类的私有属性：" + outerValue);
                System.out.println("访问外部类的方法的常量" + methodValue);
                return innerValue;
            }
        };
    }
}
interface Inner5 {
    String getInner5();
}
```



```java
public class Test {
    public static void main(String[] args) {
        // 04使用匿名内部类
        Outer4 outer4 = new Outer4();
        Inner5 inner5 = outer4.getInnerInfo("zhangsan", "lisi");
        System.out.println(inner5.getInner5());
    }
}
```

在使用匿名内部类的时候，需要记住以下几点：

- 匿名内部类必须继承一个父类或者实现一个接口。
- 在匿名内部类中需要使用外部类的方法的属性时，要求该属性必须为final类型的常量。
- 在匿名内部类中需要使用外部类的方法的形参时，要求该形参必须为final类型的常量。






## 三

### 内部类

内部类(nested classes)，面向对象程序设计中，可以在一个类的内部定义另一个类。嵌套类分为两种，即静态嵌套类和非静态嵌套类。静态嵌套类使用很少，最重要的是非静态嵌套类，也即是被称作为内部类(inner)。内部类是JAVA语言的主要附加部分。内部类几乎可以处于一个类内部任何位置，可以与实例变量处于同一级，或处于方法之内，甚至是一个表达式的一部分。

### 静态内部类

1. 静态内部类定义在类中，任何方法外，用static定义。
2. 静态内部类只能访问外部类的静态成员。
3. 生成(new)一个静态内部类不需要外部类成员:这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成:
   Outer.Inner in=new Outer.Inner();而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。可以定义私有静态内部类。
4. 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。
5. 当类与接口(或者是接口与接口)发生方法命名冲突的时候，此时必须使用内部类来实现。用接口不能完全地实现多继承，用接口配合内部类才能实现真正的多继承。
6. 举例：

```
public class Test {
    public static void main(String[] args)  {
        Outter.Inner inner = new Outter.Inner();
    }
}
 
class Outter {
	int a = 6;
	static int b = 9;
    public Outter() {
         
    }
     
    static class Inner {
        public Inner() {
             System.out,println(a);//此时这行代码会报错，因为它不能使用外部类的非static成员变量或者方法
             System.out,println(b);//正确
        }
    }
}

```

### 成员内部类

1. 成员内部类，可以访问外部类的私有成员或属性。作为外部类的一个成员存在，与外部类的属性、方法并列。
2. 内部类和外部类的实例变量可以共存。在内部类中访问实例变量:this.属性。在内部类访问外部类的实例变量:外部类名.this.属性。在外部类的外部访问内部类，使用out.inner.
3. 成员内部类的特点:
   内部类作为外部类的成员，可以访问外部类的私有成员或属性。(即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。)
   用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。
   **注意:**内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。
4. 成员内部类不能定义静态成员，只能定义对象成员。
5. 建立内部类对象时应注意:
   在外部类的内部可以直接使用inner s=new inner();(因为外部类知道inner是哪个类，所以可以生成对象)。而在外部类的外部，要生成(new)一个内部类对象，需要首先建立一个外部类对象(外部类可用)，然后在生成一个内部类对象。
   Outer o=new Outer();
   Outer.Inner in=o.new.Inner()。
6. 创建成员内部类实例时，外部类的实例必须已经存在。
7. 当内部类和外部类有同名的成员时，内部类可通过 外部类名.this.变量名 访问外部类成员。
8. 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式，这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。

```
class Circle {
    private double radius = 0;
    public static int count =1;
    public Circle(double radius) {
        this.radius = radius;
    }
     
    class Draw {     //内部类
        public void drawSahpe() {
            System.out.println(radius);  //外部类的private成员
            System.out.println(count);   //外部类的静态成员
        }
    }
}
```

1. 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
   外部类.this.成员变量；外部类.this.成员方法
2. 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：

```
class Circle {
    private double radius = 0;
 
    public Circle(double radius) {
        this.radius = radius;
        getDrawInstance().drawSahpe();   //必须先创建成员内部类的对象，再进行访问
    }
     
    private Draw getDrawInstance() {
        return new Draw();
    }
     
    class Draw {     //内部类
        public void drawSahpe() {
            System.out.println(radius);  //外部类的private成员
        }
    }
}
```

1. 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：

```
public class Test {
    public static void main(String[] args)  {
        //第一种方式：
        Outter outter = new Outter();
        Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建
         
        //第二种方式：
        Outter.Inner inner1 = outter.getInnerInstance();
    }
}
 
class Outter {
    private Inner inner = null;
    public Outter() {
         
    }
     
    public Inner getInnerInstance() {
        if(inner == null)
            inner = new Inner();
        return inner;
    }
      
    class Inner {
        public Inner() {
             
        }
    }
}
```

### 局部内部类

1. 定义：定义在方法中或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
2. 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
3. 举例：

```
class People{
    public People() {
         
    }
}
    public People getWoman(){
        class Woman extends People{   //局部内部类
            int age =0;
        }
        return new Woman();
    }
}
```

### 匿名内部类

1. 匿名内部类在java编码中不是很常见，它可一让类实现多个继承的特性。
2. 举例

```
abstract class Person {
    public abstract void eat();
}
 
class Child extends Person {
    public void eat() {
        System.out.println("eat something");
    }
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用。
但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？这个时候就引入了匿名内部类

abstract class Person {
    public abstract void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
可以看到，我们直接将抽象类Person中的方法在大括号中实现了。这样便可以省略一个类的书写。
并且，匿名内部类还能用于接口上
```

1. 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。





### 内部类的作用及意义

学会使用内部类，是掌握Java高级编程的一部分，能让你更优雅地设计自己的程序结构。

#### 2.1 为了实现封装特性

我们在另一篇文章[《面向对象三大特性的总结》](https://www.jianshu.com/p/7b08e274bc0b)中有详细介绍关于封装的常用方法，其中就有使用内部类的方法。

外部类对内部类的封装主要表现为在其它地方想要使用内部类的话需要受到外部类的限制。



```java
public class Animal {
    public class Dog {
    }
    public Dog getDog(){
        return new Dog();
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        Dog d = a.new Dog();
        Dog o = a.getDog();
        // 无法直接实例化内部类的对象，如下语句无法编译通过
        Dog g = new Dog();
    }
}
```

在如上的例子中，内部类虽然是public的，但是想要使用内部类必须借助外部类的对象才能做到，这就是封装。更进一步，如果你只希望在外部类中才能使用内部类，而在其它地方都不能使用的话，只需要将内部类改为private即可。



```java
public class Animal {
    private class Dog {
    }
    public Dog getDog(){
        return new Dog();
    }
    public static void main(String[] args) {
        Animal a = new Animal();
        // 在外部类中可以使用private的内部类，但是仍然只能通过外部类的对象才能访问
        Dog d = a.new Dog();
        Dog o = a.getDog();
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        // 下面两行语句都无法编译通过，因为Dog是private的内部类，无法在外部类之外的其它任何地方使用
        Dog d = a.new Dog();
        Dog o = a.getDog();
    }
}
```

#### 2.2 为了完善多重继承

在Java中一个子类只能继承一个父类，如果想继承多个父类，只能将这些父类改为接口，然后子类实现多个接口。然而接口中的方法都是抽象的，是必须在子类中予以实现的，这就带来了很大的不便，那有没有什么方法能让子类同时继承多个父类中的已经实现好了的方法呢？当然是通过内部类，具体示例如下：



```java
public class Animal {
    public String bark(){
        return "WOW";
    }
}
```



```java
public class Creature {
    public String drink(){
        return "water";
    }
}
```



```java
public class Mammal {
    public class Dog extends Creature {
    }
    public class Cat extends Animal {
    }
    public String getDogAction(){
        return new Dog().drink();
    }
    public String getCatAction(){
        return new Cat().bark();
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        Mammal m = new Mammal();
        // 对于Mammal来说，其通过内部类Dog和Cat间接地分别继承了Creature和Animal中的方法
        System.out.println(m.getCatAction());
        System.out.println(m.getDogAction());
    }
}
```

#### 2.3 让Java也有闭包

首先我们需要先理解什么是闭包？

闭包就是能够读取其他函数内部变量的函数。——百度百科

那么映射到Java里面，所谓的闭包就可以指在内部类中可以访问并使用外部类中的所有变量和方法的特性。那么这样的闭包究竟有什么用处呢？别急，我们先来看下面这样一个例子：



```java
public class Fruit {
    private Integer num = 10;
    private void addOneFruit(){
        num++;
        System.out.println("fruit增加到" + num + "个");
    }
    public class Child {
        public void getOneFruit(){
            num--;
            System.out.println("fruit减少到" + num + "个");
        }   
        public void putOneFruit(){
            addOneFruit();
        }
        
    }
}
```



```java
public class Test {
    public static void main(String[] args) {
        Fruit fruit = new Fruit();
        Child child = fruit.new Child();
        // 通过内部类对象引用来操作外部类的私有属性和方法（称为闭包）
        child.getOneFruit();
        child.putOneFruit();
    }
}
```

在上面的例子中，`main`方法中原来是无论如何都不能访问`Fruit`的私有属性`num`和`addOneFruit`的，但是通过内部类`Child`，这一切就成了可能，从而实现了闭包。下面是列举的关于闭包的好处：

- 使得环境外部（类、函数）可以有一种途径访问环境内的私有成员。
- 使得当前环境的对象得以一直保留在内存中，即使将该对象的引用置为null。

关于上述第一点，你是否会有这样的疑问：为什么不使用setter和getter方法对环境内的私有成员进行访问呢？

如果单从能否实现角度看，我们要访问环境内的私有成员，当然可以通过setter和getter方法，但是从面向对象编程角度看，则不能依靠这种方法。比如`Fruit`的减少只能通过`Child`的操作来进行，这是模拟现实世界中的操作“吃”，只有`Child`才能吃掉`Fruit`达到让`Fruit`减少的目的，总不能让Fruit自己吃自己吧。

关于上述的第二点，我们可以改下`main`方法进行说明：



```java
public class Test {
    public static void main(String[] args) {
        Fruit fruit = new Fruit();
        Child child = fruit.new Child();
        // 通过内部类对象引用来操作外部类的私有熟悉和方法（称为闭包）
        child.getOneFruit();
        child.putOneFruit();
        // 即使将外部类的引用置为null，但因其内部类引用仍然存在，内部类需要依赖外部类，所以外部类的对象仍然得以保留，不会被GC回收
        fruit = null;
        child.putOneFruit();
        child.getOneFruit();
        child = null;
        // 内部类的引用被置为null后，内部类的对象和外部类的对象从此就没有引用指向它们，很快会被GC回收
        // 下面两行编译无法通过
        child.getOneFruit();
        child.putOneFruit();
    }
}
```









# 十五.switch支持的数据类型



- 基本数据类型：char，byte， short， int
- 包装数据类型： Character，Byte，Short，Integer
- 枚举类型：Enum
- 字符串类型：String（Jdk 7+ 开始支持）



~~~java
public class SwitchDemo {
    public static void main(String[] args) {
        Character character = new Character('s');

        switch (character) {
            default:{
                System.out.println("默认");
            }
            case 'a': {
                System.out.println("a");
                break;
            }
            case 'b':{
                System.out.println("b");
                break;
            }
            case 'd':{
                System.out.println("d");
            }

        }
    }
}
~~~







# 十六.重载与重写



**方法重载的规则：**
1.==方法名一致==，参数列表中参数的==顺序==，==类型==，==个数不同==。
2.重载与方法的==返回值无关==，存在于父类和子类，同类中。
3.可以抛出不同的异常，可以有不同修饰符。



**方法重写的规则**：
1==.参数列表==必须完全与被重写方法的==一致==，==返回类型==必须完全与被重写方法的返回类型一致。
2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次
声明。
3.访问权限不能比父类中被重写的方法的访问权限更低。
4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是
否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则
可以。





# 十七.增强for循环、迭代器对集合的增删操作问题



普通for循环遍历集合过程中进行删除，如果进行大量删除会报IndexOutOfBoundsException异常，如果少量删除可以成功删除，但是循环的次数会减少，造成结果不准确。

   增强for循环遍历过程中进行删除，会报ConcurrentModificationException异常，并发修改异常。集合遍历时进行增删操作都需要留意是否会触发ConcurrentModificationException异常



### ==普通==for循环对集合增删操作问题

- **增加操作：**能正常添加

```java
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c");
		list.add("d");

		for (int i = 0; i < list.size(); i++) {
			if ("baidu".equals(list.get(i))) {
				list.add("com");
			} 
		}
		System.out.println(list);
	}
```

 

- **删除操作：\**有问题\****

```java
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c");
		list.add("d");
		for (int i = 0; i < list.size(); i++) {
			list.remove(i);
		}
		System.out.println(list);
	}
```

代码的原意思是删除所有元素，但结果如图，还剩两个元素

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/2019050320062755.png)

原因：每当删除一个元素时，集合的size方法的值都会减小1，这将直接导致集合中元素的索引重新排序，进一步说，就是剩余所有元素的索引值都减1，而for循环语句的局部变量i仍然在递增，这将导致删除操作发生跳跃。从而导致上述还剩两个元素。

应将循环中的代码修改如下

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20190503201322623.png)



### ==增强==for循环对集合的增删操作问题

- **增加操作：\**并发修改异常\****

```java
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c")；
		list.add("d");
		for (String s : list) {
			if ("baidu".equals(s)) {
				list.add("com");//ConcurrentModificationException
			} 
		}
		System.out.println(list);
	}
```

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20190503202147671.png)

使用javap -c 命令查看class文件的字节码

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20190503202625921.png)

由上图红框圈起的部分不难发现，foreach 循环内部实际是通过 Iterator 实现的，以上代码等同于：

```java
	public static void main(String[] args) {

		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c");
		list.add("d");
		for (Iterator<String> i = list.iterator(); i.hasNext(); ) {
		    String item = i.next();
		    if ("baidu".equals(item)) {
				list.add("com");
			} 
		}
		System.out.println(list);
	}
```

- **删除操作：\**并发修改异常，原理同增加操作一样\****

```java
	public static void main(String[] args) {

		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu")；
		list.add("c");
		list.add("d");
		for (String s : list) {
			if ("baidu".equals(s)) {
				list.remove(s);
			} 
		}
		System.out.println(list);
	}
```

 

### ==迭代器==对集合的增删操作问题

- **增加操作**：因为Iterator没有add方法，此处我们使用List特有的迭代器ListIterator
- 正常添加

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20190503203928525.png)

```java
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c");
		list.add("d");
		ListIterator<String> it = list.listIterator();
		while(it.hasNext()){
			String str = it.next();
			if ("baidu".equals(str)) {
				it.add("com");
			}
		}
		System.out.println(list);
	}
```

- **删除操作**：正常删除

```java
	public static void main(String[] args) {

		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("baidu");
		list.add("c");
		list.add("d")
            
		Iterator<String> it = list.iterator();
        
		while(it.hasNext()){
			String str = it.next();
			if ("baidu".equals(str)) {
				it.remove();
			}
		}
		System.out.println(list);
	}
```

### 为什么迭代器对集合的增删操作不会出错

原因：迭代器内部还是利用ArrayList的添加删除函数进行操作，只不过操作只有会对相应的指针进行修改（下一个），如果进行了删除操作，集合整体长度变小，指向下一个的指针也会相应减小，所以再次访问下一个时就不会发生错误了。

源码：

terator 接口包含以下几个主要方法：

```java
boolean hasNext();  // 检查是否有下个元素
E next();           // 获取下个元素
void remove();      // 移除当前指向的元素
```





# 十八.遍历Map

```java
    Map<String,Integer> map=new HashMap<String, Integer>();
    map.put("a",1);
    map.put("b",1);

    Set<String> KeySet = map.keySet();
                                            
    for (String string : KeySet) {
        System.out.println(map.get(string));
    }
}
```

```java
Set<Map.Entry<String, Integer>> entries = map.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
}
```





# 十九.关于集合

![image-20201101215210027](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201101215210027.png)



![image-20200917193307775](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200917193307775.png)







## 1.list

==有序==

——ArrayList 线程不安全，查询速度快
——Vector 线程安全，但速度慢，已被 ArrayList 替代
——LinkedList 链表结果，增删速度快
——TreeList 树型结构，保证增删复杂度都是O（log n）,

​		增删性能远高于ArrayList和LinkedList,但是稍微占用内存



## 2.set



Set：元素是==无序==(存入和取出的顺序不一定一致)，元素==不可以重复==。



——HashSet:底层数据结构是哈希表。是==线程不安全==的。不同步。



​	**HashSet 是如何保证元素唯一性的呢？**
是通过元素的两个方法，hashCode 和 equals 来完成。
如果元素的 HashCode 值相同，才会判断 equals 是否为 true。
如果元素的 hashcode 值不同，不会调用 equals。
注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的 hashcode
和 equals 方法。



——TreeSet：底层数据结构是二叉树，存放有序：TreeSet ==线程不安全==
可以对 Set 集合中的元素进行排序。
通过 compareTo 或者 compare 方法来保证元素的唯一性。





## 3.Map



——HashMap：底层数据结构是==哈希表==，允许使用 null 值和 null 键，该集合是==不同步==的。

将 hashtable 替代，jdk1.2.效率高。
——TreeMap：底层数据结构是==二叉树==。==线程不同步==。可以用于给 map 集合中的键进





## 4.List 和 Map、Set 的区别。

==结构特点==
List 和 Set 是存储**单列数据**的集合，Map 是存储键和值这样的**双列数据**的集合；

List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其
键是不能重复的，它的值是可以有重复的，Set 中存储的数据是无序的，且不允许有重复，
但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode
来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说
set 中的元素还是无序的）；
==实现类==
List 接口有三个实现类（

LinkedList：基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。					链表增删快，查找慢；
ArrayList：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除；

Vector：基于数组实现，线程安全的，效率低）。



Map 接口有三个实现类（

HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键；

HashTable：线程安全，低效，不支持 null 值和 null 键；
LinkedHashMap：是 HashMap 的一个子类，保存了记录的插入顺序；SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序）。



Set 接口有两个实现类（

HashSet：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；

LinkedHashSet：继承与HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMp）。

==区别==
List 集合中对象按照索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象，例如通过 list.get(i)方法来获取集合中的元素；

Map 中的每一个元素包含一个键和一个值，成对出现，键对象不可以重复，值对象
可以重复；Set 集合中的对象不按照特定的方式排序，并且没有重复对象，但它的实现类能
对集合中的对象按照特定的方式排序，例如 TreeSet 类，可以按照默认顺序，也可以通过
实现 Java.util.Comparator<Type>接口来自定义排序方式。



## 5.[HashSet和TreeSet的区别](https://www.cnblogs.com/cxfly/p/10540959.html)

Set中元素不可以重复，是无序的（这里无序是指存入元素的先后顺序与输出元素的先后顺序不一致）

==HashSe==t：内部的数据结构是==哈希表==，是线程==不安全==的。

  HashSet中保证集合中元素是唯一的方法：通过对象的==hashCode==和==equals==方法来完成对象唯一性的判断。

 

  如果对象的hashCode值不同，则不用判断equals方法，就直接存到HashSet中。

 

  如果对象的hashCode值相同，需要用equals方法进行比较，如果结果为true，则视为相同元素，不存，如果结果为false，视为不同元素，进行存储。

 

注意：如果元素要存储到HashCode中，必须覆盖hashCode方法和equals方法。

 

==TreeSet==：可以对Set集合中的元素进行排序，是线程==不安全==的。

  TreeSet中判断元素唯一性的方法是：根据比较方法的返回结果是否为0，如果是0，则是相同元素，不存，如果不是0，则是不同元素，存储。

  TreeSet对元素进行排序的方式：



**元素自身具备比较功能，即自然排序，需要实现Comparable接口，并覆盖其compareTo方法。**

**元素自身不具备比较功能，则需要实现Comparator接口，并覆盖其compare方法。**

注意：LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的。



# 二十.HashMap，HashTable，ConcurrentHashMap 之间的区别，及性能对比





==HashMap== 是线程==不安全==的,HashMap 是一个接口,是 Map 的一个子接口,是将键映射到
值得对象,不允许键值重复,允许空键和空值;由于非线程安全,HashMap 的效率要较HashTable的==效率高==一些.

==HashTable==是线程==安全==的一个集合,==不允许== ==null 值==作为一个 key 值或者 Value 值;
HashTable 是 sychronize,多个线程访问时不需要自己为它的方法实现同步,而
HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;





==性能==：ConcurrentHashMap(线程安全) > HashMap > HashTable(线程安全)
==区别对比一==(**HashMap** 和 **HashTable** 区别)：
1、HashMap 是非线程安全的，HashTable 是线程安全的。
2、HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。
3、因为线程安全的问题，HashMap 效率比 HashTable 的要高。
4、Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable
适合于多线程环境。一般现在不建议用 HashTable, ①是 HashTable 是遗留类，内部实现很
多没优化和冗余。②即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有
必要因为是多线程而用 HashTable。
==区别对比二==(**HashTable** 和 **ConcurrentHashMap** 区别)：
HashTable 使用的是 Synchronized 关键字修饰，ConcurrentHashMap 是使用了锁分段技术
来保证线程安全的。
Hashtable 中采用的锁机制是一次锁住整个 hash 表，从而在同一时刻只能由一个线程对其
进行操作；而 ConcurrentHashMap 中则是一次锁住一个桶。

ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get、put、remove 等常用操作只锁
住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，
并发性能的提升是显而易见的。
想要具体了解 ConcurrentHashMap 和 HashTable 对比及底层原理可以参考一下链接：
https://www.jianshu.com/p/a7767e6ff2a2









# 二十一.泛型

**泛型的本质是为了==参数化类型==（在不创建新的类型的情况下，通过泛型指定的不同类型来==控制形参具体限制的类型==**。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

```
// 泛型的好处：
//   1. 省略了强转的代码。
//   2. 可以把运行时的问题提前到编译时期。
```

还可以提高代码的可读性和安全性。



# 二十二.面向对象都有哪些特性，以及你对这些特性的理解

1）==继承==：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继
承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

提高了软件的可重用性和可扩展性。

**继承父类所有的的属性和方法，==除了==private（私有）和构造方法**

2） ==封装==：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象
的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。

就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节

3） ==多态性==：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调
用同样的方法但是做了不同的事情。多态性分为==编译时==的多态性和==运行时==的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，   **父类类型的变量引用子类类型对象**
但一切对 A 系统来说都是透明的。==方法重载==（overload）实现的是==编译时==的多态性（也称为前绑定），而方==法重写==（override）实现的是==运行时==的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做  								指程序中定义的对象引用所指向的具体类型在运行期间才确定。	
两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

​    多态分为编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。

4）==抽象==：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对
象有哪些属性和行为，并不关注这些行为的细节是什么。



## ==多态==

用最简单的一句话就是：==父类型的引用==指向==子类型的对象==。用一句比较通俗的话：**同一操作作用于不同的对象，可以产生不同的效果**。这就是多态。

这句话很好理解：Person person = new Student("张三")；但是这个多态有什么作用呢？而我们又为什么要是有多态呢？

首先讲下封装和继承：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面，他把实现的细节影藏起来了，比如你在java中去实现一个类，这个类中提供了一些功能方法，你只需要知道你需要传递什么样的参数，会达到什么样的效果，实现细节在类中定义好了。从而使得代码模块化；而继承可以扩展已存在的代码模块，而目的就是为了代码重用。

那么**多态除了代码的复用，还可以解耦**。然而为什么要解耦？耦合度讲的是模块模块之间，代码代码之间的关联度，通过对系统的分析把他分解成一个一个子模块，子模块提供稳定的接口，达到降低系统耦合度的的目的，模块模块之间尽量使用模块接口访问，而不是随意引用其他模块的成员变量。



**==多态有什么好处==？**

有两个好处：

1. 应用程序不必为每一个子类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。//继承 
2. **子类的功能**可以被**父类的方法**或**引用变量**所**调用**，这叫向后兼容，可以提高可扩充性和可维护性。 //多态的真正作用，

 

多态在什么地方用？

可以用在方法的参数中和方法的返回类型中。

在方法的返回类型中，请看下面的例子：

上面的例子中,不管是JD还是Benz都是我们自己直接new出来的.我们可以设计一个工厂类,专门生成汽车

/**
\*  我们将多态使用在方法的返回类型中
\*  Driver可以是抽象类,也可以是接口,JD和Benz分别继承该类或实现该借口

*/

这实际上就是设计模式中的简单工厂模式!

类型的参数.,传入参数的时候,可以传入任何一个类的对象，只要是对应的类的对象名称就可以了
这就是多态的应用!





# 二十三.String 、StringBuilder 、StringBuffer 的区别？



1）String 是只读字符串，==final==关键字字符数组保存字符串， private final char value[] 也就意味着 String 引用的字符串内容是不能被改变的。

2）StringBuffer/StringBuilder 表示的字符串对象可以直接进行修改。

3）StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被 synchronized 修饰，因此它的效率理论上也比 StringBuffer 要高。

StringBuilder 与 StringBuffer **都继承**自==AbstractStringBuilder== 类



**String覆盖了object类的equals方法，==可以==用 “+”  拼接**

**StringBuffer没有覆盖equals方法，==不能==用  ”+“  拼接**



对于三者使用的总结：
1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = **StringBuilder**    线程不安全
3. 多线程操作字符串缓冲区下操作大量数据 = **StringBuffer**     线程安全



# 二十四.== 与 equals



========== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。

(==基本数据==类型     “ == ” 比较的是==值==，==引用数据==类型    " == "    比较的是==内存地址==)

equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”
比较这两个对象。
情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；
若它们的内容相等，则返回 true (即，认为这两个对象相等)。







# 二十五. 基本概念：程序、进程、线程



==程序(program)==为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。

==进程(process)==是程序的一次执行过程，或是**正在运行的一个程序**。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期
			如：运行中的QQ，运行中的MP3播放器

​					程序是静态的，进程是动态的

​					**进程作为资源分配的单位**，系统在运行时会为每个进程分配不同的内存区域
==线程(thread)==，进程可进一步细化为线程，是一个程序内部的一条执行路径。

- 若一个进程同一时间并行执行多个线程，就是支持多线程的
- 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小
- 一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。





## 并行与并发

并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。
并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。



理解：

　　（1）并行是指两个或者多个事件在**同一时刻**发生；而并发是指两个或多个事件在同一时间间隔发生。

　　（2）并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。

　　（3）在一台处理器上“同时”（这个同时实际上是交替“”）处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群

　　普通解释：

　　并发：交替做不同事情的能力

　　并行：同时做不同事情的能力

　　专业术语：

　　并发：不同的代码块交替执行

　　并行：不同的代码块同时执行



![image-20200918200330950](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200918200330950.png)

![image-20200918200315676](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20200918200315676.png)

# 二十六.多线程



## 生命周期

![image-20201004212755288](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201004212755288.png)

![image-20201002213451383](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201002213451383.png)





## **常用方法**

String ==getName==()

```
      返回该线程的名称。
```

static Thread==currentThread==()

```
      返回对当前正在执行的线程对象的引用。
```

void ==setName(String name)==

```
      改变线程名称，使之与参数 name 相同。
```

static void ==sleep(long millis)==

```
 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
```



void   ==setDaemon(true)==

~~~java
将线程设置为守护线程
~~~



void ==start()==

```
      使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
```

Thread(String name)

~~~java
    分配新的 Thread 对象。
~~~



## 一.继承 Thread 类

//1、作为Thread的子类，并重写run方法。把多线程的业务写在run方法中
//2、默认实现是super.run();
//3、创建线程对象
//4、开启线程：谁抢到资源谁就先执行**

```
  public class Test1  {

    public static void main(String[] args) {

       //3、创建线程对象
       ThreadDemo t1 = new ThreadDemo("钢铁侠");

       ThreadDemo t2 = new ThreadDemo("美队");

       //4、开启线程：谁抢到资源谁就先执行
       t1.start();
       t2.start();
       //t1.run();//当做常规方法调用，且 不会发生多线程现象
    }
}

//1、作为Thread的子类，并重写run方法。把多线程的业务写在run方法中
class ThreadDemo extends Thread{
	public ThreadDemo() {}

    public ThreadDemo(String name) {
       super(name);
    }

    @Override
    public void run() {
       //2、默认实现是super.run();
       for (int i = 0; i < 10; i++) {
           System.out.println(getName()+i);
       }
    }
}
```

## 二.多线程创建2：实现Runnable接口

**//1，实现Runnable接口，重写run()
//2，构造创建对象，传入Runnable子类
//3.开启线程*

常用方法
void run()

```
      使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。

public class Test2 {

    public static void main(String[] args) {

       MyThread t = new MyThread ();

       //2，构造创建对象，传入Runnable子类
       Thread target = new Thread(t);
	   Thread target2 = new Thread(t);

       //开启线程
       target.start();
       target2.start();
    }
}

//1，实现Runnable接口，重写run()
class MyThread implements Runnable{

    @Override
    public void run() {
       for (int i = 0; i < 10; i++) {
       System.out.println(Thread.currentThread().getName()+" "+i);
       }
    }
}
```

## 三.多线程创建3：实现Callable接口

**implements Callable
Runnable 和 Callable 的区别是，
（1）Callable 规定的方法是 call（），Runnable 规定的方法是 run（）。
（2）Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得
（3）call 方法可以抛出异常，run 方法不可以
（4）运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。**



与使用runnable方式相比，callable功能更强大些：
runnable重写的run方法不如callaalbe的call方法强大，call方法可以有返回值
方法可以抛出异常
支持泛型的返回值
需要借助FutureTask类，比如获取返回结果

~~~java
* //callable实现新建线程的步骤：
 * 1.创建一个实现callable的实现类
 * 2.实现call方法，将此线程需要执行的操作声明在call（）中
 * 3.创建callable实现类的对象
 * 4.将callable接口实现类的对象作为传递到FutureTask的构造器中，创建FutureTask的对象
 * 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start方法启动（通过FutureTask的对象调用方法get获取线程中的call的返回值）
 * 
 * */


//实现callable接口的call方法
class NumThread implements Callable{

    private int sum=0;//

    //可以抛出异常
    @Override
    public Object call() throws Exception {
        for(int i = 0;i<=100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+":"+i);
                sum += i;
            }
        }
        return sum;
    }
}

public class ThreadNew {

    public static void main(String[] args){
        //new一个实现callable接口的对象
        NumThread numThread = new NumThread();

        //通过futureTask对象的get方法来接收futureTask的值
        FutureTask futureTask = new FutureTask(numThread);

        Thread t1 = new Thread(futureTask);
        t1.setName("线程1");
        t1.start();

        try {
            //get返回值即为FutureTask构造器参数callable实现类重写的call的返回值
           Object sum = futureTask.get();
           System.out.println(Thread.currentThread().getName()+":"+sum);
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
~~~



## 四.使用线程池的方式：

**背景**：经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
**思路**：提前创建好多个线程，放入线程池之，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。（数据库连接池）
**好处**：提高响应速度（减少了创建新线程的时间）
降低资源消耗（重复利用线程池中线程，不需要每次都创建）
便于线程管理
corePoolSize:核心池的大小
maximumPoolSize:最大线程数
keepAliveTime：线程没有任务时最多保持多长时间后会终止
。。。。。。

JDK 5.0 起提供了线程池相关API：ExecutorService 和 Executors
ExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor.
void execute(Runnable coommand):执行任务/命令，没有返回值，一般用来执行Runnable
Futuresubmit(Callable task):执行任务，有返回值，一般又来执行Callable
void shutdown（）：关闭连接池。

| Executors                           | 工具类，线程池的工厂类，用于创建并返回不同类型的线程池       |
| ----------------------------------- | ------------------------------------------------------------ |
| Executors.newCachedThreadPool()     | 创建一个可根据需要创建新线程的线程池                         |
| Executors.newFixedThreadPool(n)     | 创建一个可重用固定线程数的线程池                             |
| Executors.newSingleThreadExecutor() | :创建一个只有一个线程的线程池                                |
| Executors.newScheduledThreadPool(n) | 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 |

线程池构造批量线程代码如下：

```
package com.example.paoduantui.Thread;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 创建线程的方式四：使用线程池（批量使用线程）
 *1.需要创建实现runnable或者callable接口方式的对象
 * 2.创建executorservice线程池
 * 3.将创建好的实现了runnable接口类的对象放入executorService对象的execute方法中执行。
 * 4.关闭线程池
 *
 * */

class NumberThread implements Runnable{


    @Override
    public void run() {
        for(int i = 0;i<=100;i++){
            if (i % 2 ==0 )
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}

class NumberThread1 implements Runnable{
    @Override
    public void run() {
        for(int i = 0;i<100; i++){
            if(i%2==1){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

public class ThreadPool {

    public static void main(String[] args){

        //创建固定线程个数为十个的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        //new一个Runnable接口的对象
        NumberThread number = new NumberThread();
        NumberThread1 number1 = new NumberThread1();

        //执行线程,最多十个
        executorService.execute(number1);
        executorService.execute(number);//适合适用于Runnable

        //executorService.submit();//适合使用于Callable
        //关闭线程池
        executorService.shutdown();
    }

}

```

目前两种方式要想调用新线程，都需要用到Thread中的start方法。

## java virtual machine（JVM）：java虚拟机内存结构

程序（一段静态的代码）——————》加载到内存中——————》进程（加载到内存中的代码，动态的程序）
进程可细分为多个线程，一个线程代表一个程序内部的一条执行路径
每个线程有其独立的程序计数器（PC，指导着程序向下执行）与运行栈（本地变量等，本地方法等）
![在这里插入图片描述](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/2019060623371913.png)

> 大佬传送门：https://blog.csdn.net/bluetjs/article/details/52874852



## 总结

.**第一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法，然后
在 run 方法里填写相应的逻辑代码。**



第二种方法是实现 Runnable 接口，并编写 run 方法,相比继承 Thread 类创建线程的好处是
以实现接口的方式创建线程可以对类进行更好的扩展，该类可以继承其他类来扩展自身需
求，相比第一种方式更加灵活，扩展性强。

实现 Callable 接口创建线程与 Runnable 接口的不同之处在于：如果你想要在线程执行完
毕之后得到带有返回值的线程则实现 Callable 接口







# 实现同步两种方法：

一种是同步方法，另一种是同步代码块。

==同步方法==是在方法返回类型前面加上 synchronized 关键字

==同步代码块==是 synchronized (这里写需要同步的对象){…}

同步锁
把有可能出现问题的代码包起来，一次只让一个线程执行。通过sychronized关键字实现同步。

当多个对象操作共享数据时，可以使用同步锁解决线程安全问题。

```java
 synchronized
synchronized(对象){

    需要同步的代码；

}
123456
```

### 同步代码块

是 synchronized (这里写需要同步的对象){…}

```java
public class Test4 {

    public static void main(String[] args) {

       Ticket2 t = new Ticket2();

       Thread target = new Thread(t, "窗口1");
       Thread target2 = new Thread(t, "窗口2");
       Thread target3 = new Thread(t, "窗口3");
       Thread target4 = new Thread(t, "窗口4");

        target.start();
        target2.start();
       target3.start();
       target4.start();
    }
}
class Ticket2 implements Runnable {
    
	private int tic = 100;
    Object obj = new Object();
    @Override
    public void run() {

       while (true) {
           // 把有线程安全问题的代码，用同步关键字包起来
           // 原理：用一个对象作为一把锁，给代码上锁，一个线程访问锁代码时，其他线程只能等待锁释放才能进来。
           // 多线程间要使用同一把锁才可以真的把代码锁住实现线程安全。  
// synchronized (new Object()) {//锁了不同对象
           // synchronized (obj) {//锁了同一个对象
//synchronized (Ticket2.class) {//锁了本类，针对于静态
           synchronized (this) {
              if (tic > 0) {
                  try {
                     Thread.sleep(100);
                  } catch (InterruptedException e) {
                     e.printStackTrace();
                  }
                  System.out.println(tic--);
              }
           }
       }
    }
}
```



### 同步方法

是在方法返回类型前面加上 synchronized 关键字

```java
public synchronized void run()
{
    ... ...
}  
```





### sychronizd锁对象

同步代码块：自己定义的任意对象

同步方法：调用该方法的对象，也就是this指向的对象

静态方法：该方法的类的class对象





# 乐观锁与悲观锁



## **何谓悲观锁与乐观锁**

> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。



## **悲观锁**

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中==`synchronized==`和`==ReentrantLock==`等独占锁就是悲观锁思想的实现。



## **乐观锁**

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是**在更新的时候会判断一下在此期间别人有没有去更新这个数据**，可以使用==版本号机制==和==CAS算法==实现。**乐观锁适用于==多读==的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。



## **两种锁的使用场景**

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**



## **乐观锁常见的两种实现方式**

> **乐观锁一般会使用版本号机制或CAS算法实现。**



**1. 版本号机制**

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。



**举一个简单的例子：**
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。

1. 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
2. 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
3. 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
4. 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。



这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。



**2. CAS算法**

即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。**CAS算法**涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。



## **乐观锁的缺点**

> ABA 问题是乐观锁一个常见的问题



**1 ABA 问题**

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **"ABA"问题。**

JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。



**2 循环时间长开销大**

**自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。** 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。



**3 只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。



## **CAS与synchronized的使用情景**

> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**

1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。



**补充：**

Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。



作者：Amsour丶

链接：[http://www.imooc.com/article/details/id/44217](https://link.zhihu.com/?target=http%3A//www.imooc.com/article/details/id/44217)

来源：慕课网

本文原创发布于慕课网 ，转载请注明出处，谢谢合作

------

**推荐阅读：**

[【官方】手记栏目认证作者招募，长期有效，随时报名！_慕课手记](https://link.zhihu.com/?target=https%3A//www.imooc.com/article/24589)

[有奖征文005期 |人生路上得一良师，是何感受？](https://zhuanlan.zhihu.com/p/38522496)

[Vue菜鸟从业记：没准备好的面试，那叫尬聊](https://zhuanlan.zhihu.com/p/39987182)

[【干货整理】Docker，从入门说起……](https://zhuanlan.zhihu.com/p/40129549)

[Java干货整理，从入门说起（7.11）](https://zhuanlan.zhihu.com/p/39522453)

[如何确定自己是否适合做程序员？](https://www.zhihu.com/question/35256075/answer/256747303)

[半路学编程，可以成为大牛吗？](https://www.zhihu.com/question/34101611/answer/370155398)

[如何使用 GitHub？](https://www.zhihu.com/question/20070065/answer/415539043)

[在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进？](https://www.zhihu.com/question/68611994/answer/445456606)

[你看过/写过哪些有意思的代码？](https://www.zhihu.com/question/275611095/answer/432656082)

[如何在程序里留下彩蛋？](https://www.zhihu.com/question/271409373/answer/375941716)

[为什么部分程序员下班后只关显示器不关电脑？](https://www.zhihu.com/question/59303310/answer/399313148)

[有哪些好笑的关于程序员的笑话？](https://www.zhihu.com/question/19909094/answer/288419603)

[如何防止自己被人肉搜索到？](https://www.zhihu.com/question/48691691/answer/434635442)

[搞定计算机网络面试，看这篇就够了（补充版）](https://zhuanlan.zhihu.com/p/42298499)





# 二十七.线程安全与非线程安全



==线程安全==就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

 ==线程不安全==就是不提供数据访问保护，有可能出现多个线程先后更改数据，造成所得到的数据是脏数据







# 二十八.如何理解事务



事务：是指一组数据库操作，这组操作对数据库所做的修改，

- 要么全部成功，提交到数据库生效；
- 要么全部失败，数据库回滚到这组操作之前的状态。



事务保证了数据库中数据的一致性，防止了脏数据的出现。所以，为了使数据库中的数据保持一致性，开发中往往要用到事务管理。

在JDBC中，用Connection对象进行事务管理：默认情况是事务自动提交，但也可以将自动提交关闭，改为用手动commit提交，rollback回滚。

在Spring中，用TransactionManager进行事务管理，通过Spring注入来完成。借助于java的反射机制，在事务控制方法（通常是Service层）的前后获取事务开启session。在执行数据库操作过程中，若出现了异常，spring会捕获该异常并进行回滚操作；若没有出现异常，则其间的数据库操作成功，数据会被提交到数据库的。事务执行完毕，spring会自动关闭需要关闭的东西。

spring容器集成了TransactionTemplate，它封装了所有对事务的处理功能，包括出现异常时的事务回滚、成功时的事务提交等等复杂的业务功能。事务管理由spring容器来管理之后，大大减少了程序员代码量不说，更是对事务管理提供了非常好的控制。

spring对SessionFactory配置也进行了整合，不需要再通过hibernate.cfg.xml来对SessionFactory进行设定，这样就可以利用spring强大的事务管理功能，避免了每次涉及数据库的操作都要获得session实例来启动、提交、回滚事务以及try-catch操作。这其实利用了AOP的思想，使业务开发逻辑更清晰，分工更加明确。

spring中的事务管理要防止出现脏读、不可重复读、幻读问题，就需要将隔离级别设置为“串行化”。



## 事务的四大特性（ACID）

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：

### 1、原子性（Atomicity）  

　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

### 2、一致性（Consistency）

　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

### 3、隔离性（Isolation）

　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

### 4、持久性（Durability）

　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，
即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。



## 事务的隔离级别（默认事务级别为可重复读）

总的说，数据库事务无非就两种：读取事务（select）、修改事务（update,insert）。在没有事务隔离控制的时候，多个事务在同一时刻对同一数据的操作可能就会影响到最终期望的结果，通常有四种情况：
（1） 两个更新事务同时修改一条数据时，很显然这种情况是最严重的了，程序中无论如何也不能出现这种情况，因为它会造成更新的丢失！
（2） 一个更新事务更新一条数据时，另一个读取事务读取了还没提交的更新，这种情况下会出现读取到脏数据。
（3） 一个读取事务读取一条数据时，另一个更新事务修改了这条数据，这时就会出现不可重现的读取。
（4）一个读取事务读取时，另一个插入事务（注意此处时插入）插入了一条新数据，这样就可能多读出一条数据，出现幻读。
以上四种情况描述完毕，相信大家也发现规律了，前三种是对同一条数据的并发操作，对程序的结果可能产生致命影响，尤其是金融等实时性，准确性要求极高的系统，绝不容许这三中情况的出现，
相比第四种情况不会影响数据的真实性，在很多情况下是允许的，如社交论坛等实时性要求不高的系统！
综上四个情况，我们可以大致这样简单的理解（最初说的两种事务的自由组合2*2=4）：
A） 修改时允许修改（丢失更新）
B） 修改时允许读取（脏读）
C) 读取时允许修改（不可重复读）
D) 读取时允许插入（幻读）
从上到下问题越来越不严重，但所需的性能开销却越大。因为不同的系统允许不同级别的情况，所以就出现了事务隔离这么一个东东，来允许我们设定数据库的并发行为。



总结下

​	**如果不考虑事务的隔离性，会发生的几种问题：**

1，==脏读==
　　**脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。**
　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下
  update account set money=money+100 where name=’B’;  (此时A通知B)
  update account set money=money - 100 where name=’A’;
　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。

2，==不可重复读==
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。
　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。
　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……

3，==虚读(幻读)==
　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

 SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。



## MySQL数据库的四种事务隔离级别



### Read Uncommitted（读取未提交内容）

​    在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）；

### Read Committed（读取提交内容）

​    这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果；

### Repeatable Read（可重读）

​    这是**==MySQL==**的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
​    简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
​    InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题

### Serializable（可串行化） 

​    这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
​     这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

​     脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
​     不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
​     幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
​     在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：
​     
​     ![20151219142625513.jpg (838Ã267)](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20151219142625513.jpg)
　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
　　③ Read committed (读已提交)：可避免脏读的发生。
　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。

　　**在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)**；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。

　　在MySQL数据库中查看当前事务的隔离级别： select @@tx_isolation;

　　在MySQL数据库中设置事务的隔离 级别：  

```
 set  [glogal | session]  transaction isolation level 隔离级别名称;

 set tx_isolation=’隔离级别名称;’
```

例1：查看当前事务的隔离级别：

　　![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/787876-20160313202200007-1111796802.png)

例2：将事务的隔离级别设置为Read uncommitted级别：

　　![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/787876-20160313202224241-2101542210.png)

或：

　　![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/787876-20160313202245210-345198166.png)

记住：设置数据库的隔离级别一定要是在开启事务之前！

　　如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：

　　![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/787876-20160313202333460-377269897.png)

在JDBC中设置隔离级别的部分代码：

　　![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/787876-20160313202355694-2106931487.png)

　　后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。







# 二十九.如何理解同步请求和异步请求

个例子：普通B/S模式（同步）AJAX技术（异步）

**同步**：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

**异步**: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

同步交互，就是最常见的click-refresh模式，点一个连接或提交一个表单，然后整个页面被刷新

异步交互，当前很热的AJAX就是典型例子，提交请求返回对象是不可见的层，然后用javascripts根据返回数据，改变当前页面显示，譬如google map



==同步请求==在请求完成前，所有操作都不能进行，一直等到请求完成。

==异步请求==在请求完成前，可以继续发送请求，不会造成请求阻塞。



**同步**

所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。

**异步**
将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应了。你可以关闭界面了。

同步，是所有的操作都做完，才返回给用户结果。即写完数据库之后，再响应用户，用户体验不好。
异步，不用等所有操作都做完，就相应用户请求。即先响应用户请求，然后慢慢去写数据库，用户体验较好。

**异步操作例子**

为了避免短时间大量的数据库操作，就使用缓存机制，也就是消息队列。先将数据放入消息队列，然后再慢慢写入数据库。

引入消息队列机制，虽然可以保证用户请求的快速响应，但是并没有使得数据迁移的时间变短（即80万条数据写入mysql需要1个小时，用了redis之后，还是需要1个小时，只是保证用户的请求的快速响应。用户输入完http url请求之后，就可以把浏览器关闭了，干别的去了。如果不用redis，浏览器不能关闭）。

**同步就没有任何价值了吗？**

银行的转账功能。
![在这里插入图片描述](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/20161204112435761)







# 三十.抽象类与接口（修饰符）

### 访问控制修饰符总结

| **访问级别** | **访问控制修饰符** | **同类** | **同包** | **子类(不同包)** | **不同包(其他类)** |
| ------------ | ------------------ | -------- | -------- | ---------------- | ------------------ |
| 公共         | public             | 允许     | 允许     | 允许             | 允许               |
| 受保护       | protected          | 允许     | 允许     | 允许             | 不允许             |
| 默认         | 没有修饰符         | 允许     | 允许     | 不允许           | 不允许             |
| 私有         | private            | 允许     | 不允许   | 不允许           | 不允许             |

 

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
| `default`   | Y      | Y        | Y              | N                                                            | N      |
| `private`   | Y      | N        | N              | N                                                            | N      |





## 相同点

1. 都可以被继承

2. 都可以包含方法声明

3. 都不可以实例化

4. 都可以包含抽象方法，接口的==实现类==和抽象类的==子类==只有==全部实现==了接口或者抽象类中的方法后才可以被==实例化==。

5. # 

   | 类型       |                        abstract class                        | Interface                                                    |
   | :--------- | :----------------------------------------------------------: | :----------------------------------------------------------- |
   | 定义       |                     abstract class关键字                     | Interface关键字                                              |
   | 继承       | 抽象类可以继承一个类和实现多个接口；子类只可以继承一个抽象类 | 接口只可以继承接口（一个或多个）；子类可以实现多个接口       |
   | 访问修饰符 | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符       |
   | 方法实现   |           可定义构造方法，可以有抽象方法和具体方法           | 接口完全是抽象的，没构造方法，且方法都是抽象的，不存在方法的实现 |
   | 实现方式   | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
   | 作用       |             为了把相同的东西提取出来,**即重用**              | 为了把程序模块进行固化的契约,是**为了降低偶合**              |

   # 



## 不同点

1. 抽象类中既可以包含抽象方法，也可以包含非抽象的普通方法；而接口中的方法必须是抽象方法

2. 抽象类中的抽象方法的访问类型可以是==public==、==protected==、==default==，

   ​                         但接口中的抽象方法只能是==public   abstract== 类型的

3. 抽象类中可以有普通成员变量，而接口中的所有变量均为==`public static final==`修饰，即均为常量

4. 抽象类里可以有构造方法，而接口中==不能==有**构造方法**

5. 抽象类里可以有静态方法，而接口中==不能==有**静态方法**

6.  一个类可以实现多个接口，但只能继承一个抽象类

7. 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法







# 三十一.常见的异常

1）java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。
2）java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序
		试图通过字符串来加载某个类时可能引发异常。
3）java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。
4）java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。
5）java.lang.IllegalArgumentException 方法传递参数错误。
6）java.lang.ClassCastException 数据类型转换异常。
7）java.lang.NoClassDefFoundException 未找到类定义错误。
8）SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。
9）java.lang.InstantiationException 实例化异常。
10）java.lang.NoSuchMethodException 方法不存在异常。





# 三十二.内部类有什么作用?

内部类可以有多个实例,每个实例都有自己的状态信息,并且==与其他外部对象的信息相互独立==.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.

创建内部类对象的时刻==不依赖于外部类对象的创建==.

内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.

此外,内部类提供了==更好的封装,除了该外部类,其他类都不能访问==.



二、 作用

1.==内部类可以很好的实现隐藏==

 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以

2．==内部类拥有外围类的所有元素的访问权限==

3.可是实现==多重继承==

4.可以避免修改接口而实现同一个类中两种同名方法的调用。







# 三十四.static都有哪些用法?



所有的人都知道static关键字这两个基本的用法:==静态变量==和==静态方法==.也就是被static所修饰的变量/方法都属于类的静态资源,==类实例所共享==.

除了静态变量和静态方法之外,static也用于==静态块==,多用于==初始化==操作:

```java
public calss PreCache{
    
    static{
        //执行相关操作
    }
}
```

此外static也多用于修饰内部类,此时称之为==静态内部类==.



# 三十五.tomcat崩溃怎么办



设置tomcat内存

解决方法，在tomcat的启动文件（catalina.sh）中添加如下参数,加大永久带的内存

-XX:PermSize=256M  -XX:MaxPermSize=512M





# 三十六.ajax属性

~~~java
$.ajax({  
      type:"GET",//通常会用到两种：GET,POST。默认是：GET  
      url:"a.php",//(默认: 当前页地址) 发送请求的地址  
      dataType:"html",//预期服务器返回的数据类型。  
      data：
      success:callback, //请求成功  
      error:error,//请求出错   
      complete:complete//请求完成  
   });  
~~~







# 三十七.数据结构



## 数据结构有哪些

### 图：

有向图：
无向图：

图的存储结构：
1，邻接矩阵(数组表达)
2，邻接表和十字链表，链表表达，主要表达有向图
3，邻接 表，链表，无向图

最小生成树：

***prim（普里姆算法）\***

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zNTc0NDAzLTQ1ZjVjMzk1M2JlNjJiYjEuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA)


***kruskal（克鲁斯卡尔算法）\***

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zNTc0NDAzLTYxZmYyYTQxYjRjMGY4ZGQuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA)

形成闭环就抛弃

 

### 队列：

普通队列：很多缺点，处理数据时入队或出队，浪费内存
环形队列：充分利用每个内存

### 栈：

先进后出

树：
有序树
无序树

二叉树：所有结点的度都小于等于2
***数组表达：\***

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zNTc0NDAzLWE1NWNkYzA3YjZkOTdkY2MuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjYxL2Zvcm1hdC93ZWJw)


***链表实现：\***

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zNTc0NDAzLTUzYTZiODZlZDFjOWQ0NzIuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTIyL2Zvcm1hdC93ZWJw)

 

### 线性表：

是n个数据元素的有序序列

***顺序表\***（数组表达）：前驱，后继。指特别元素的前面和后面的元素

***链表\***：静态链表，单链表，循环链表，双向链表

![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zNTc0NDAzLWQwNTdkM2ZkOTZlMWY3ZjYuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTAyMy9mb3JtYXQvd2VicA)

 

 



## 图的遍历方式

深度优先

广度优先



# 三十八.什么是关系型数据库

关系型数据库最典型的**数据结构是表**，由**二维表**及其**之间的联系**所组成的一个数据组
织。

关系型数据库以==行和列的形式存储数据==



# 三十九.克隆

## 1.浅克隆

```java
public class Address {
    private Integer id;
    private String province;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getProvince() {
        return province;
    }

    public void setProvince(String province) {
        this.province = province;
    }
}
```



```java
public class Person implements Cloneable{

    private String name;
    private Integer age;

    private Address address;

    public Person() {
    }

    public Person(String name, Integer age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public class Clone1 {
    public static void main(String[] args) throws CloneNotSupportedException {


        Address a=new Address();
        a.setId(1);
        a.setProvince("天津");

        Person p = new Person("zhang", 23,a);
        Person p1 = p;
        Person p2 = (Person) p.clone();

        System.out.println(p);
        System.out.println(p1);
        System.out.println(p2);

        System.out.println("------");

        System.out.println( p.getAddress());;
        System.out.println( p1.getAddress());;
        System.out.println( p2.getAddress());;

    }
}
```



## 2.深克隆

```java
public class Person implements Cloneable {

    private String name;
    private Integer age;

    private Address address;

    public Person() {
    }

    public Person(String name, Integer age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {

        Person person = (Person) super.clone();
        Address clone = (Address) person.getAddress().clone();
        person.setAddress(clone);
        return person;
//        return super.clone();
    }
}
```







# 四十.反射



# 四十一.sql语言分类

DDL：Data Difinition Language 数据定义语言，bai一般du用来库和表头的创建和删zhi除；

DML：Data Manipulation Language 数据操作语言，一般用来做表中数据的增加和删除；

DQL：Data Query Language 数据查询语言，用来在数据库中查询的语言，你说的select就在这里；

DCL：Data Control Language 数据控制语言，一般是DBA才会用到的数据库用户管理及日常维护语言。



==sqlserver==(T_SQL):
DDL—数据定义bai语言(CREATE，ALTER，DROP，DECLARE)
DML—数据操纵语言(SELECT，DELETE，UPDATE，INSERT)
DCL—数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK)
==Oracle SQL==(P_SQL) 语句zhi可以分为以下几类dao:
1.数据操作语言语句[Data manipulation language，DML]
2.数据定义语言语句[Data definition language，DDL]
3.事务控制语句[transaction control statement]
4.会话控制语句[session control statement]





# 四十二. 常见的数据结构有哪些？

## 1.数组：

数组是最常用的数据结构，数组的特点是==长度固定==，可以用下标索引，并且所有的
元素的==类型==都是==一致==的。数组常用的场景有：从数据库里读取雇员的信息存储为
EmployeeDetail[ ];把一个字符串转换并存储到一个字节数组中便于操作和处理等等。尽量
把数组封装在一个类里，防止数据被错误的操作弄乱。另外，这一点也适合其他的数据结构。

## 2.列表：

列表和数组很相似，只不过它的==大小==可以==改变==。列表一般都是通过一个固定大小的
数组来实现的，并且会在需要的时候自动调整大小。列表里可以包含重复的元素。常用的
场景有，添加一行新的项到订单列表里，把所有过期的商品移出商品列表等等。一般会把列
表初始化成一个合适的大小，以减少调整大小的次数。

## 3.集合：

集合和列表很相似，不过它==不能==放==重复==元素。

## 4.堆栈：

堆栈==只允许对最后插入的元素进行操作==（也就是==后进先出==，Last In First Out –
LIFO）。如果你移除了栈顶的元素，那么你可以操作倒数第二个元素，依次类推。这种后进
先出的方式是通过仅有的 peek(),push()和 pop()这几个方法的强制性限制达到的。

## 5.队列：

队列和堆栈有些相似，不同之处在于在队列里第一个插入的元素也是第一个被删除
的元素（即是==先进先出==）。这种先进先出的结构是通过只提供 peek()，offer()和 poll()
这几个方法来访问数据进行限制来达到的。例如，排队等待公交车，银行或者超市里的等待
列队等等，都是可以用队列来表示。

## 6.链表：

链表是一种由==多个节点==组成的数据结构，并且每个节点包含有数据以及指向下一个
节点的引用，在双向链表里，还会有一个指向前一个节点的引用。例如，可以用单向链表和
双向链表来实现堆栈和队列，因为链表的两端都是可以进行插入和删除的动作的。当然，也
会有在链表的中间频繁插入和删除节点的场景。Apache 的类库里提供了一个 TreeList 的实
现，它是链表的一个很好的替代，因为它只多占用了一点内存，但是性能比链表好很多。也
就是说，从这点来看链表其实不是一个很好的选择。







# 四十三.redis的隔离机制



# 四十四.static与单例模式区别



# 四十五.线程池

1. 什么是线程池,如何使用?
线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接
去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。
在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法.
26 / 196
然后调用他们的 execute 方法即可。
合理利用线程池能够带来三个好处。
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，
还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控.
2. 常用的线程池有哪些？
newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序
按照任务的提交顺序执行。
newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到
线程达到线程池的最大大小。
newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线
程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。
newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执
行任务的需求。




# 四十六.native方法

native主要用于方法上

1、一个native方法就是一个==Java==调用==非Java==代码的==接口==。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。

2、在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外面实现的。

native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。

不过，对Java外部的调用通常不能移植到其他平台，在applet中还可能引发安全异常。实现本地代码将使您的Java应用程序无法通过100%纯Java测试。但是，如果必须执行本地调用，则要考虑几个准则：

1.将您的所有本地方法都封装到一个类中，这个类调用单个的DLL。对每一种目标操作系统平台，都可以用特定于适当平台的版本的DLL。这样可以将本地代码的影响减少到最小，并有助于将以后所需要的移植问题考虑在内。

2.本地方法尽量简单。尽量使您的本地方法对第三方（包括Microsoft）运行时DLL的依赖减少到最小。使您的本地方法尽量独立，以将加载您的DLL和应用程序所需的开销减少到最小。如果需要运行时DLL，必须随应用程序一起提供。


JNI的书写步骤如下：


a.编写带有native声明的方法的Java类


b.使用javac命令编译编写的Java类


c.使用java -jni ****来生成后缀名为.h的头文件


d.使用其他语言（C、C++）实现本地方法


e.将本地方法编写的文件生成动态链接库


以下是一个在Java中调用本地C程序的简单的例子：


a.编写HelloWorld.java类



```java
class HelloWorld {

    public native void hello();
    static {
        System.loadLibrary("hello");
    }

    public static void main(String[] args) {
        new HelloWorld().hello();
    }
}
```




b.编译
javac  HelloWorld.java


c.生成.h文件
javah  -jni  HelloWorld


生成内容如下：

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */ #
include <jni.h>
/* Header for class HelloWorld */
#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {#
    endif
    /*
     * Class: HelloWorld
     * Method: hello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_HelloWorld_hello(JNIEnv * , jobject);#
    ifdef __cplusplus
}#
endif# endif
```





第一个参数是调用JNI方法时使用的JNI Environment指针。第二个参数是指向在此Java代码中实例化的Java对象HelloWorld的一个句柄。其他参数是方法本身的参数


d.c实现



```cpp
#include < jni.h > 
#include "HelloWorld.h"
#include < stdio.h > 

JNIEXPORT void JNICALL Java_HelloWorld_hello(JNIEnv * env, jobject obj) {

    printf("Hello World!\n");
    return;

}
```






其中，第一行是将jni.h文件引入（在%JAVA_HOME%\include目录下），里边有JNIEnv和jobject的定义。


e.编译c实现


这里以在Windows中为例，需要生成dll文件。在保存HelloWorldImpl.c文件夹下面，使用VC的编译器cl成。


cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloWorldImp.c -Fehello.dll


注意：生成的dll文件名在选项-Fe后面配置，这里是hello，因为在HelloWorld.java文件中我们loadLibary的时候使用的名字是hello。当然这里修改之后那里也需要修改。另外需要将-I%java_home%\include -I%java_home%\include\win32参数加上，因为在第四步里面编写本地方法的时候引入了jni.h文件。


6) 运行程序

java HelloWorld 就ok了！



# 四十七.Math类常用方法

~~~java
鉴于java求整时欲生欲死，整理常用math如下：

1： java取整

     a：floor向下取整

       用法：Math.floor(num)

       Math.floor(1.9)//1                      Math.floor(-1.9)//-2

    b:  round四舍五入

      用法：Math.round(num)实际上是等价于Math.floor(num+0.5)

      Math.round(1.5)//2                     Math.round(1.4)//1

      Math.round(-1.4)//-1                  Math.round(-1.5)//-1               Math.round(-1.6)//-2

    c:  ceil向上取整

       用法: Math.ceil(num)

       Math.ceil(1.4)//2      Math.ceil(1.5)//2             Math.ceil(1.6)//2

       Math.ceil(-1.4)//-1   Math.ceil(-1.5)//-1           Math.ceil(-1.6)//-1

    d:  神级方法直接加(int)强制转换，直接去掉小数点位，没有任何向上向下，需要时最好用的方法

 

2： java求绝对值

     Math.abs(num)

     Math.abs(-30.5)//30.5

3:   java随机数

     Math.random()随机去0~1的数

     (int)(100*Math.random())这样就可以取0~100随机整数

4： java幂函数

     Math.pow(a,b)a的b次方

     Math.pow(x,2)就是平方

     Math.pow(x,3)就是立方

5： java开根号

     Math.sqrt(num)num的平方根
~~~





# 四十八.mysql查询随机十条数据

```sql
SELECT * FROM tablename ORDER BY RAND() LIMIT 10
```



# 一些易错题

## 基本数据类型

![image-20201021193838611](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201021193838611.png)

![image-20201021193851476](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201021193851476.png)



## 代码块执行顺序

![image-20201021194534531](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/image-20201021194534531.png)



## `String s = new String("abc")`创建了几个String对象?

2个.一个是字符串字面常数,在字符串常量池中;另一个是new出来的字符串对象,在堆中.





## java 创建对象的几种方式

java中提供了以下四种创建对象的方式:

- new创建新对象
- 通过反射机制
- 采用clone机制
- 通过序列化机制

前两者都需要显式地调用构造方法. 对于clone机制,需要注意浅拷贝和深拷贝的区别,对于序列化机制需要明确其实现原理,在java中序列化可以通过实现Externalizable或者Serializable来实现.





## 深拷贝和浅拷贝的区别是什么?



- 浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.
- 深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.



## 什么是编译器常量?使用它有什么风险?

公共静态不可变,即public static final修饰的变量就是我们所说的编译期常量.这里的public可选的.实际上这些变量在编译时会被替换掉,因为编译器明确的能推断出这些变量的值(如果你熟悉C++,那么这里就相当于宏替换).

编译器常量虽然能够提升性能,但是也存在一定问题:你使用了一个内部的或第三方库中的公有编译时常量,但是这个值后面被其他人改变了,但是你的客户端没有重新编译,这意味着你仍然在使用被修改之前的常量值.





## java当中使用什么类型表示价格比较好?

如果不是特别关心内存和性能的话,使用BigDecimal.否则使用预定义精度的 double 类型



## a=a+b与a+=b有什么区别吗?

`+=`操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：

```java
byte a = 127;
byte b = 127;

b = a + b; // 报编译错误:cannot convert from int to byte
b += a; 
```



## 以下代码是否有错,有的话怎么改？

```java
short s1= 1;
s1 = s1 + 1;
```

有错误.short类型在进行运算时会自动提升为int类型,也就是说`s1+1`的运算结果是int类型,而s1是short类型,此时编译器会报错.



## 以下代码是否有错,有的话怎么改？

```java
short s1= 1; 
s1 += 1; 
```

+=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.



## 了解泛型么?简述泛型的上界和下界?

有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作,这时候就需要通配符了?在Java中常见的通配符主要有以下几种:

- `<?>`: ==无限制通配符==
- `<? extends E>`: ==extends== 关键字声明了类型的==上界==,表示参数化的类型可能是所指定的类型,或者是此类型的子类
- `<? super E>`:==super==关键字声明了类型的==下界==,表示参数化的类型可能是指定的类型,或者是此类型的父类
- 

它们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型.

- `< ? extends E>`: 用于灵活**==读取==**，使得方法可以读取 E 或 E 的任意子类型的容器对象。
- `< ? super E>`: 用于灵活**==写入或比较==**,使得对象可以写入父类型的容器,使得父类型的比较方法可以应用于子类对象。

用简单的一句话来概括就是为了获得最大限度的灵活性,要在表示生产者或者消费者的输入参数上使用通配符,使用的规则就是:生产者有上限(读操作使用extends),消费者有下限(写操作使用super).



## 垃圾回收

## 简单的解释一下垃圾回收?

JVM中垃圾回收机制最基本的做法是分代回收.内存中的区域被划分成不同的世代,对象根据其存活的时间被保存在对应世代的区域中.一般的实现是划分成3个世代:年轻,年老和永久代.所有新生成的对象优先放在年轻代的(大对象可能被直接分配在老年代,作为一种分配担保机制),年轻代按照统计规律被分为三个区:一个Eden区，两个 Survivor区.在年轻代中经历了N次垃圾回收后仍然存活的对象,就会被放到年老代中.因此可以认为年老代中存放的都是一些生命周期较长的对象.

方法区也被称为永久代,用于存储每一个java类的结构信息:比如运行时常量池,字段和方法数据,构造函数和普通方法的字节码内容以及类,实例,接口初始化时需要使用到的特殊方法等数据,根据虚拟机实现不同,GC可以选择对方法区进行回收也可以不回收.

对于不同的世代可以使用不同的垃圾回收算法。比如对由于年轻代存放的对象多是朝生夕死,因此可以采用标记-复制,而对于老年代则可以采用标记-整理/清除.

### Minor GC

发生在新生代的GC为Minor GC .在Minor GC时会将新生代中还存活着的对象复制进一个Survivor中,然后对Eden和另一个Survivor进行清理.所以,平常可用的新生代大小为Eden的大小+一个Survivor的大小.

### Major GC

在老年代中的GC则为Major GC.

### Full GC

通常是和Major GC等价的,针对整个新生代,老年代,元空间metaspace(java8以上版本取代perm gen)的全局范围的GC.

关于GC的类型,其实依赖于不同的垃圾回收器.可以具体查看相关垃圾回收器的实现.

### 新生代进入老年代

- 分配担保机制:当Minor GC时,新生代存活的对象大于Survivor的大小时,这时一个Survivor装不下它们,那么它们就会进入老年代.
- 如果设置了-XX：PretenureSizeThreshold5M 那么大于5M的对象就会直接就进入老年代.
- 在新生代的每一次Minor GC 都会给在新生代中的对象+1岁,默认到15岁时就会从新生代进入老年代,可以通过-XX：MaxTenuringThreshold来设置这个临界点

## 常见的垃圾回收算法有哪些?简述其原理.

垃圾回收从理论上非常容易理解,具体的方法有以下几种:

1. 标记-清除
2. 标记-复制
3. 标记-整理
4. 分代回收
   更详细的内容参见[深入理解垃圾回收算法](http://blog.csdn.net/dd864140130/article/details/50084471)



## 如何判断一个对象是否应该被回收?

这就是所谓的对象存活性判断,常用的方法有两种:

- 引用计数法

- 对象可达性分析

  由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.



## 怎么检测一个线程是否持有对象锁

Thread类提供了一个Native方法`holdsLock(Object obj)`方法用于检测是否持有某个对象锁:当且仅当对象obj的锁被某线程持有的时候才会返回true.

```java
 public static native boolean holdsLock(Object obj);
```



java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁

```java
Object o = new Object();

@Test
public void test1() throws Exception {
    new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized(o) {
                System.out.println("child thread: holdLock: " + 
                    Thread.holdsLock(o));
            }
        }
    }).start();

    System.out.println("main thread: holdLock: " + Thread.holdsLock(o));
    Thread.sleep(2000);
}
```

main thread: holdLock: false
child thread: holdLock: true



![img](%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/v2-ed2ee29da007914d43371eff5eed6ba7_hd.jpg)





















































































































































